<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Legacy C in modern C&#43;&#43; - Henrick Deschamps</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Legacy C in modern C&#43;&#43;" />
<meta property="og:description" content="This post deals with the strategy of integration of old C code in a modern C&#43;&#43; architecture, beyond the technical point of view." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hnrck.io/blog/posts/2020-06-13-1-legacy-c-in-modern-cpp/" />
<meta property="article:published_time" content="2020-06-13T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-06-13T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Legacy C in modern C&#43;&#43;"/>
<meta name="twitter:description" content="This post deals with the strategy of integration of old C code in a modern C&#43;&#43; architecture, beyond the technical point of view."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen" href="https://hnrck.io/blog/css/main.css" /><link rel="stylesheet" type="text/css" href="https://hnrck.io/blog/css/dark.css"  />
</head><body>
        <div class="content"><header>
	<div class="main">
		<a href="https://hnrck.io/blog/">Henrick Deschamps</a>
	</div>
	<nav>
		
		<a href="/blog/">Home</a>
		
		<a href="/blog/posts">All posts</a>
		
		<a href="/blog/about">About</a>
		
		<a href="/blog/tags">Tags</a>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Legacy C in modern C&#43;&#43;</h1>
			<div class="meta">Posted on Jun 13, 2020</div>
		</div>
		

		<section class="body">
			<p><strong>[tl;dr]</strong> The integration of <code>C</code> in <code>C++</code> was designed a long time ago and the mechanisms are efficient but spartan, forcing the client code to take care to manage memory and data access. When integrating into modern <code>C++</code>, where there is often a culture of good memory management and pointer manipulation, these mechanisms are not comfortable. There are solutions to interface <code>C</code> code more cleanly, through OOP or or <code>C++</code> smart pointers.</p>
<hr>
<p>Code source of the full example available on <a href="https://github.com/hnrck/legacy_c_example">hnrck/legacy_c_example</a>.</p>
<hr>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#motivations">Motivations</a></li>
<li><a href="#context">Context</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#discussions">Discussion</a>
<ul>
<li><a href="#integrating-c-in-c++">Integrating C in C++</a></li>
<li><a href="#wrapped-integration">Wrapped integration</a></li>
<li><a href="#smart-pointers-integration">Smart pointers integration</a></li>
</ul>
</li>
<li><a href="#experimentation">Experimentation</a>
<ul>
<li><a href="#github-repository">GitHub repository</a></li>
<li><a href="#compilation">Compilation</a></li>
<li><a href="#execution">Execution</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="motivations">Motivations</h1>
<p>It has been a long time since the last time I wrote an article.
Not for lack of an idea, I thought of this one shortly after the first article.
But writing the first article took me a lot of time and energy, and basically it was too long to be useful.
I think my PhD student background played a key factor at the time.
I had an idea, a willingness to share something, and I reapplied the same rigid structure that I used in my scientific articles, which is clearly not science here.
This blog should rather be used to say what goes through my head, even if it&rsquo;s not as rigorous as my scientific work.</p>
<p>As of now, I have been a PhD for almost a year.
I left a multinational company to join another one, and it works for me for now.
I am working more on execution than simulation at the moment, but I have inherited a certain background in simulation that I would like to share.</p>
<hr>
<h1 id="context">Context</h1>
<p>In the simulation business, reusability and compatibility are very important.
A simulation model can have a very long lifetime, and today with MBSE approaches, a simulation model can exceed the lifetime of the component it simulates.</p>
<p>In this context, it is reasonable to be willing to create models that are as accessible as possible outside of the environment in which they were created, and as far as I am aware, the worst thing that can happen to a simulation model that is intended to be reused is to be developed in an exotic, or worse, specific language.</p>
<hr>
<h1 id="introduction">Introduction</h1>
<p>In my PhD thesis, I had abstracted the problem by treating the model interface as a signature, implementable, and I think this compromise is a good way forward.
Here is the compromise I propose: Implementing simulation models in a stable, portable language that can be trusted to be reused as is for decades to come, without modifying a single line of code, and in parallel, improving the simulator to take advantage of technical improvements.
From my point of view, and if there is a guarantee that the simulation scheduling is mastered, which is what I propose in my thesis, then the best of both worlds will be made use of.</p>
<p>On the one hand there is a set of models on which it is possible to capitalize and keep an archive for analysis, and on the other hand the performance of the simulation is constantly improving.</p>
<p>From my point of view, there is only one language that offers confidence in reusability and compatibility, and that is <code>C</code>, ANSI standard.</p>
<p>No matter what architecture is used, no matter what kind of embedded system, no matter how old it is, there is always a way to compile and run C89.
So the question is, why not develop everything in <code>C89</code> since it&rsquo;s so good?
This is a good question, unfortunately the <code>C89</code> suffers from shortcomings when it comes to quickly implementing a complex architecture&hellip;
Specifically <code>C89</code> does not offer the possibility to easily implement object-oriented or functional paradigms, and these are the paradigms that designers use, and they are right to do so.
I&rsquo;m the first one to criticize the object-oriented, I think this paradigm is too far from reality, but I must admit that when I design a solution, I rely on it a lot, and it simplifies my job.</p>
<p><code>C++</code> is just one of those languages that implement the object-oriented paradigm, that&rsquo;s the main difference with <code>C</code>, and that&rsquo;s where there is a huge divergence with <code>C</code>.
Beyond the technical question of integration, how to integrate elements designed in one language with its paradigms in another language, with its own paradigms.</p>
<hr>
<h1 id="discussions">Discussions</h1>
<p>When I took up the <code>ROSACE</code> case study for my thesis, a lot of implementation work had already been done on it, including in <code>C</code>.
I wanted to quickly reuse these <code>C</code> elements, but in a much more modern solution.
I hesitated between <code>C++</code> and <code>python</code>, and in the end, it was <code>C++</code> which answered best to the other needs of my thesis.</p>
<h2 id="integrating-c-in-c">Integrating C in C++</h2>
<p>Integrating <code>C</code> code into <code>C++</code> is technically incredibly simple, one just have to use:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">extern</span> <span style="color:#0ff;font-weight:bold">&#34;C&#34;</span>
</code></pre></div><p>Thus, for a function declaration in a <code>C</code> header as following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">int</span> old_func(<span style="color:#fff;font-weight:bold">int</span> x);
</code></pre></div><p>This function can be used in <code>C++</code> code as in <code>C</code> code:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_func(<span style="color:#ff0;font-weight:bold">42</span>);
</code></pre></div><p>As long as the header is included such as in the following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">extern</span> <span style="color:#0ff;font-weight:bold">&#34;C&#34;</span> {
    <span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;header.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span><span style="color:#0f0;font-weight:bold"></span>}
</code></pre></div><p>Or if the header includes the following code:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#0f0;font-weight:bold">#ifdef __cplusplus
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#fff;font-weight:bold">extern</span> <span style="color:#0ff;font-weight:bold">&#34;C&#34;</span> {
<span style="color:#0f0;font-weight:bold">#endif
</span><span style="color:#0f0;font-weight:bold"></span>
<span style="color:#007f7f">/* ...declarations ... */</span>

<span style="color:#0f0;font-weight:bold">#ifdef __cplusplus
</span><span style="color:#0f0;font-weight:bold"></span>}
<span style="color:#0f0;font-weight:bold">#endif
</span></code></pre></div><p>Which is not always the case with legacy code.</p>
<p>But the question of reuse strategy comes up very quickly.</p>
<p>Two solutions emerge: either to take over the paradigms of the old language or to implement those of the new one.
Here in the integration of <code>C89</code> in <code>C++</code> (11 at the time of my thesis, but I will use C++20 in this article), it is either a question of choosing the procedural approach and reusing functions in the same way as one would do in <code>C</code>, or using classes to encapsulate.
Thus, a declared <code>C</code> structure:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">struct</span> old_struct {
    <span style="color:#fff;font-weight:bold">int</span> x;
};
<span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> old_struct old_struct_t;
</code></pre></div><p>Can be manipulated in <code>C++</code> as a native <code>C++ struct</code>, i.e. with default constructor and all public members.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> os = old_struct();
os.x = <span style="color:#ff0;font-weight:bold">42</span>;
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = os.x;
</code></pre></div><p>However, the use of C-structures is not just for packaging data, and there are sometimes associated functions that process these structures.
Here let&rsquo;s simply consider a getter and a setter on the x property:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">void</span> old_struct_set_x(old_struct_t *p_old_struct, <span style="color:#fff;font-weight:bold">int</span> x);
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">int</span> old_struct_get_x(<span style="color:#fff;font-weight:bold">const</span> old_struct_t *p_old_struct);
</code></pre></div><p>The passage by reference does not exist in <code>C</code>, it will be necessary to switch back to a way of calling the functions on these not so modern structures, directly inherited from C:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> os = old_struct();
old_struct_set_x(&amp;os, <span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_struct_get_x(&amp;os);
</code></pre></div><p>More complicated, if the legacy code contains private implementations, such as:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">struct</span> old_pimpl;
<span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> old_pimpl old_pimpl_t;
</code></pre></div><p>In <code>C++</code>, it will be necessary to manipulate all the allocation, initialization, destruction and manipulation functions as in <code>C</code>.
Here let&rsquo;s consider these functions:</p>
<p>Allocation and initialization:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">old_pimpl_t *old_pimpl_new();
</code></pre></div><p>Finalization and destruction:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">void</span> old_pimpl_del(old_pimpl_t *p_old_pimpl);
</code></pre></div><p>Data manipulation:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">void</span> old_pimpl_set_x(old_pimpl_t *p_old_pimpl, <span style="color:#fff;font-weight:bold">int</span> x);
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#fff;font-weight:bold">int</span> old_pimpl_get_x(<span style="color:#fff;font-weight:bold">const</span> old_pimpl_t *p_old_pimpl);
</code></pre></div><p>The usage of the old private implementation is heavy:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> p_op = old_pimpl_new();
old_pimpl_set_x(p_op, <span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_pimpl_get_x(p_op);
old_pimpl_del(p_op);
</code></pre></div><h2 id="wrapped-integration">Wrapped integration</h2>
<p>The obvious solution to avoid inheriting the cumbersome use of <code>C</code> is to adapt the old structures and interface with a single class.
For our <code>old_struct</code>, the <code>OldStructWrapper</code> class can be declared.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldStructWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>Aggregation with a public structure consists of a simple private declaration:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldStructWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span>:
    old_struct os;
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>Data manipulation can be hidden behind methods to get the most out of <code>C++</code>.
The client of the <code>OldStructWrapper</code> class will not have to explicitly manipulate pointers and references:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldStructWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> set_x(<span style="color:#fff;font-weight:bold">int</span> x) {
        old_struct_set_x(&amp;os, x);
    }
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>The compiler may receive more complete information, such as the prohibition of not retrieving the result, or the purity of the method:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldStructWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">[[nodiscard]]</span> <span style="color:#fff;font-weight:bold">auto</span> get_x() <span style="color:#fff;font-weight:bold">const</span> -&gt; <span style="color:#fff;font-weight:bold">int</span> {
        <span style="color:#fff;font-weight:bold">return</span> old_struct_get_x(&amp;os);
    }
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>The <code>OldStructWrapper</code> class can therefore be completely explicitly implemented:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#007f7f">/// Old struct wrapper
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">class</span> OldStructWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#fff;font-weight:bold">private</span>:
    old_struct os; <span style="color:#007f7f">///&lt; Old struct composition
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#007f7f">/// Old struct constructor
</span><span style="color:#007f7f"></span>    OldStructWrapper() = <span style="color:#fff;font-weight:bold">default</span>;

    <span style="color:#007f7f">/// Old struct destructor
</span><span style="color:#007f7f"></span>    ~OldStructWrapper() = <span style="color:#fff;font-weight:bold">default</span>;

    <span style="color:#007f7f">/// Old struct copy constructor
</span><span style="color:#007f7f"></span>    OldStructWrapper(<span style="color:#fff;font-weight:bold">const</span> OldStructWrapper &amp;) = <span style="color:#fff;font-weight:bold">default</span>;

    <span style="color:#007f7f">/// Old struct copy assignment
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \return Copy of other old struct wrapper
</span><span style="color:#007f7f"></span>    OldStructWrapper &amp;<span style="color:#fff;font-weight:bold">operator</span>=(<span style="color:#fff;font-weight:bold">const</span> OldStructWrapper &amp;) = <span style="color:#fff;font-weight:bold">default</span>;

    <span style="color:#007f7f">/// Old struct move constructor
</span><span style="color:#007f7f"></span>    OldStructWrapper(OldStructWrapper &amp;&amp;) = <span style="color:#fff;font-weight:bold">default</span>;

    <span style="color:#007f7f">/// Old struct move assignment
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \return Old struct wrapper
</span><span style="color:#007f7f"></span>    OldStructWrapper &amp;<span style="color:#fff;font-weight:bold">operator</span>=(OldStructWrapper &amp;&amp;) = <span style="color:#fff;font-weight:bold">default</span>;

    <span style="color:#007f7f">/// Property x setter
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \param x value to set
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> set_x(<span style="color:#fff;font-weight:bold">int</span> x) {
        old_struct_set_x(&amp;os, x);
    }

    <span style="color:#007f7f">/// Property x getter
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \return x value
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">[[nodiscard]]</span> <span style="color:#fff;font-weight:bold">auto</span> get_x() <span style="color:#fff;font-weight:bold">const</span> -&gt; <span style="color:#fff;font-weight:bold">int</span> {
        <span style="color:#fff;font-weight:bold">return</span> old_struct_get_x(&amp;os);
    }
};
</code></pre></div><p>There must be at least 3 lines of code to declare the class, 1 to associate the old structure and 2 lines for each function to be reused.
The more lines there are in my code and the less I feel comfortable as a written line is a line to maintain, but it must be admitted here that the addition remains acceptable.</p>
<p>For private implementations, the work is more complex.
For aggregation, the compiler can&rsquo;t know the size in memory at compile time, so you have to use a pointer:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#fff;font-weight:bold">private</span>:
    old_pimpl_t *p_op{<span style="color:#fff;font-weight:bold">nullptr</span>};
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>The constructor and destructor must then be overridden to allocate the old private implementation and deallocate it:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
    OldPimplWrapper() : p_op{old_pimpl_new()} {};

    ~OldPimplWrapper() {
        old_pimpl_del(p_op);
    }
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>In addition, the copying of data from old private implementations has to be considered when copying the wrappers:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    OldPimplWrapper(<span style="color:#fff;font-weight:bold">const</span> OldPimplWrapper &amp;other) : p_op{old_pimpl_new()} {
        set_x(other.get_x());
    }

    OldPimplWrapper &amp;<span style="color:#fff;font-weight:bold">operator</span>=(<span style="color:#fff;font-weight:bold">const</span> OldPimplWrapper &amp;other) {
        set_x(other.get_x());
        <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
    }
<span style="color:#007f7f">// ...
</span></code></pre></div><p>As well as moving the memory in the move constructor / assignment of the wrappers:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    OldPimplWrapper(OldPimplWrapper &amp;&amp;other) <span style="color:#fff;font-weight:bold">noexcept</span>: p_op{<span style="color:#fff;font-weight:bold">nullptr</span>} {
        p_op = other.p_op;
        other.p_op = <span style="color:#fff;font-weight:bold">nullptr</span>;
    }

    OldPimplWrapper &amp;<span style="color:#fff;font-weight:bold">operator</span>=(OldPimplWrapper &amp;&amp;other) <span style="color:#fff;font-weight:bold">noexcept</span> {
        p_op = other.p_op;
        other.p_op = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
    }
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>Before being able to encapsulate the old functions as in the case of the public structure:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> set_x(<span style="color:#fff;font-weight:bold">int</span> x) {
        old_pimpl_set_x(p_op, x);
    }
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span>:
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">[[nodiscard]]</span> <span style="color:#fff;font-weight:bold">auto</span> get_x() <span style="color:#fff;font-weight:bold">const</span> -&gt; <span style="color:#fff;font-weight:bold">int</span> {
        <span style="color:#fff;font-weight:bold">return</span> old_pimpl_get_x(p_op);
    }
<span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>The <code>OldPimplWrapper</code> class can therefore be completely explicitly implemented:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#007f7f">/// Old private implementation wrapper
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">class</span> OldPimplWrapper <span style="color:#fff;font-weight:bold">final</span> {
<span style="color:#fff;font-weight:bold">private</span>:
    p_old_pimpl_t p_op{<span style="color:#fff;font-weight:bold">nullptr</span>}; <span style="color:#007f7f">///&lt; Pointer to old private implementation, null by default
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#007f7f">/// Old private implementation constructor
</span><span style="color:#007f7f"></span>    OldPimplWrapper() : p_op{old_pimpl_new()} {};

    <span style="color:#007f7f">/// Old private implementation destructor
</span><span style="color:#007f7f"></span>    ~OldPimplWrapper() {
        old_pimpl_del(p_op);
    }

    <span style="color:#007f7f">/// Old private implementation copy constructor
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \param other Old private implementation wrapper to copy
</span><span style="color:#007f7f"></span>    OldPimplWrapper(<span style="color:#fff;font-weight:bold">const</span> OldPimplWrapper &amp;other) : p_op{old_pimpl_new()} {
        set_x(other.get_x());
    }

    <span style="color:#007f7f">/// Old private implementation copy assignment
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \param other Old private implementation wrapper to copy
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \return Copy of other
</span><span style="color:#007f7f"></span>    OldPimplWrapper &amp;<span style="color:#fff;font-weight:bold">operator</span>=(<span style="color:#fff;font-weight:bold">const</span> OldPimplWrapper &amp;other) {
        set_x(other.get_x());
        <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
    }

    <span style="color:#007f7f">/// Old private implementation move constructor
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \param other Old private implementation wrapper to move
</span><span style="color:#007f7f"></span>    OldPimplWrapper(OldPimplWrapper &amp;&amp;other) <span style="color:#fff;font-weight:bold">noexcept</span>: p_op{<span style="color:#fff;font-weight:bold">nullptr</span>} {
        p_op = other.p_op;
        other.p_op = <span style="color:#fff;font-weight:bold">nullptr</span>;
    }

    <span style="color:#007f7f">/// Old private implementation move assignment
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \param other old private implementation wrapper to move
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \return Other
</span><span style="color:#007f7f"></span>    OldPimplWrapper &amp;<span style="color:#fff;font-weight:bold">operator</span>=(OldPimplWrapper &amp;&amp;other) <span style="color:#fff;font-weight:bold">noexcept</span> {
        p_op = other.p_op;
        other.p_op = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
    }

    <span style="color:#007f7f">/// Property x setter
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \param x value to set
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> set_x(<span style="color:#fff;font-weight:bold">int</span> x) {
        old_pimpl_set_x(p_op, x);
    }

    <span style="color:#007f7f">/// Property x getter
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/// \return x value
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">[[nodiscard]]</span> <span style="color:#fff;font-weight:bold">auto</span> get_x() <span style="color:#fff;font-weight:bold">const</span> -&gt; <span style="color:#fff;font-weight:bold">int</span> {
        <span style="color:#fff;font-weight:bold">return</span> old_pimpl_get_x(p_op);
    }
};
</code></pre></div><p>Here are at least 3 lines of code to declare the class, 1 to associate the old structure and 2 lines for each function to be reused, 1 line for the constructor, 2 for the destructor, at least 5 for copying and 6 for moving, unless they are explicitly deleted with the delete statement, which makes the class maintenance easier, but makes the client integration more complex.
Thus, the main drawback of this solution is the more or less important quantity of code to add between the old library and the client, and the cost that this implies in code maintenance.</p>
<p>The end result is valuable, old private structures and implementations can be manipulated as simple classes:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> os = OldStructWrapper();
os.set_x(<span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = os.get_x();
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> op = OldPimplWrapper();
op.set_x(<span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = op.get_x();
</code></pre></div><p>And  copy / move constructor / assignment help the client with high level memory manipulation, especially for the fan of &lsquo;<code>}</code>&rsquo; as the best destructor.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">OldStructWrapper os_cpy_1;
OldStructWrapper os_cpy_2;

{
    <span style="color:#fff;font-weight:bold">auto</span> os = OldStructWrapper();
    os.set_x(<span style="color:#ff0;font-weight:bold">42</span>);
    os_cpy_1 = os; <span style="color:#007f7f">// Copy assignment
</span><span style="color:#007f7f"></span>    os_cpy_2 = OldStructWrapper(os); <span style="color:#007f7f">// Copy constructor and move assignment
</span><span style="color:#007f7f"></span>}

os_cpy_2.set_x(<span style="color:#ff0;font-weight:bold">24</span>);

<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X_1 = os_cpy_1.get_x();
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X_2 = os_cpy_2.get_x();
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">OldPimplWrapper op_cpy_1;
OldPimplWrapper op_cpy_2;

{
    <span style="color:#fff;font-weight:bold">auto</span> op = OldPimplWrapper();
    op.set_x(<span style="color:#ff0;font-weight:bold">42</span>);
    op_cpy_1 = op; <span style="color:#007f7f">// Copy assignment
</span><span style="color:#007f7f"></span>    op_cpy_2 = OldPimplWrapper(op); <span style="color:#007f7f">// Copy constructor and move assignment
</span><span style="color:#007f7f"></span>}

op_cpy_2.set_x(<span style="color:#ff0;font-weight:bold">24</span>);

<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X_1 = op_cpy_1.get_x();
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X_2 = op_cpy_2.get_x();
</code></pre></div><h2 id="smart-pointers-integration">Smart pointers integration</h2>
<p>What has just been presented is an integration solution based on the use of classes to hide the complexity of memory management, while providing cleaner access to data manipulation.
Access to data manipulation is just a plus and the key is to improve memory management, and in modern <code>C++</code> a native solution exists.
It is called smart pointers.
Smart pointers are one of the mechanics of RAII, whose objective is to create a notion of data ownership.
When the owner of a single pointer is destroyed (end of scope or end of life of an object), the single pointer is also destroyed, which is perfect for the fans of &lsquo;<code>}</code>&rsquo; as the best destuctor.
Use of smart pointers is very simple, the declaration of aliases can be done this way:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">using</span> UpOldStruct = std::unique_ptr&lt;old_struct&gt;;
</code></pre></div><p>Allocation and initialization can be even be done in a single instruction using standard library tools:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">std::make_unique&lt;T&gt;(T *);
</code></pre></div><p>Such as in the following example:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> up_os = std::make_unique&lt;old_struct&gt;();
old_struct_set_x(up_os.get(), <span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_struct_get_x(up_os.get());
</code></pre></div><p>For the private implementation, the tools already exist to easily implement the use, the declaration for aliases is done as with a classical structure, specifying that we will provide a handle to the destructor:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">using</span> UpOldPimpl = std::unique_ptr&lt;old_pimpl_t, <span style="color:#fff;font-weight:bold">void</span> (*)(p_old_pimpl_t)&gt;;
</code></pre></div><p>The creation is done by allocating the memory and providing the connection to the destuctor, and then manipulating the smart pointer like a classical structure pointer:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> up_op = UpOldPimpl(old_pimpl_new(), old_pimpl_del);
old_pimpl_set_x(up_op.get(), <span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_pimpl_get_x(up_op.get());
</code></pre></div><p>Note: as for now, <code>make_unique</code> can not be used with destructor overloading.</p>
<p>The same can be done with shared pointers:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">std::make_shared&lt;T&gt;(T *);
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> sp_os = std::make_shared&lt;old_struct&gt;();
old_struct_set_x(sp_os.get(), <span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_struct_get_x(sp_os.get());
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#fff;font-weight:bold">auto</span> sp_op = std::shared_ptr&lt;old_pimpl&gt;(old_pimpl_new(), old_pimpl_del);
old_pimpl_set_x(sp_op.get(), <span style="color:#ff0;font-weight:bold">42</span>);
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> X = old_pimpl_get_x(sp_op.get());
</code></pre></div><hr>
<h1 id="experimentation">Experimentation</h1>
<h2 id="github-repository">GitHub repository</h2>
<p>The code source of the full example available is on <a href="https://github.com/hnrck/c-integration-modern-cpp">hnrck/c-integration-modern-cpp</a>.</p>
<p>The GitHub repository is structured as following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">    .
    ├── CMakeLists.txt
    ├── LICENSE
    ├── README.md
    ├── extern
    │   └── Catch2
    ├── inc
    ├── old_func
    ├── old_pimpl
    ├── old_struct
    └── tests
</code></pre></div><ul>
<li>inc - containing the integration in headers <code>*.h</code>, using the legacy <code>C</code> in modern <code>C++</code>.</li>
<li><a href="https://github.com/hnrck/c-integration-modern-cpp/blob/master/CMakeLists.txt"><code>CMakeLists.txt</code></a> - allowing to build the project quickly.</li>
<li><code>old_*/inc</code> - containing the legacy <code>C</code> headers.</li>
<li><code>old_*/src</code> - containing the legacy <code>C</code> implementations.</li>
<li><a href="https://github.com/hnrck/c-integration-modern-cpp/blob/master/LICENSE"><code>LICENSE</code></a> - the license of the project.</li>
<li><code>tests</code> - containing the examples implementations runnable, as exposed in this article.</li>
</ul>
<p>To test the project, the easiest way is to clone the github repository:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git clone https://github.com/hnrck/c-integration-modern-cpp.git --branch 1.0.0
</code></pre></div><h2 id="compilation">Compilation</h2>
<p>These commands build the legacy <code>C</code> libraries in <code>c-integration-modern-cpp/build/</code> as well as the integration executables.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cmake -Bc-integration-modern-cpp-build -Hc-integration-modern-cpp
cmake --build c-integration-modern-cpp-build -t all
</code></pre></div><h2 id="execution">Execution</h2>
<p>The main applications can be executed with:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cmake --build c-integration-modern-cpp-build -t <span style="color:#fff;font-weight:bold">test</span>
</code></pre></div><p><a href="https://asciinema.org/a/orjHjbV7VHNKdRH8j1WF526UX"><img src="https://asciinema.org/a/orjHjbV7VHNKdRH8j1WF526UX.svg" alt="asciicast"></a></p>
<h1 id="conclusion">Conclusion</h1>
<p>The integration of <code>C</code> in <code>C++</code> was designed a long time ago and the mechanisms are efficient but spartan, forcing the client code to take care to manage memory and data access.
When integrating into modern <code>C++</code>, where there is often a culture of good memory management and pointer manipulation, these mechanisms are not comfortable.
There are solutions to interface <code>C</code> code more cleanly, through classes or smart pointers.
None of these solutions is perfect and all of them have limitations, but they have their advantages that we will summarize in the following paragraph.</p>
<h2 id="summary">Summary</h2>
<table>
<thead>
<tr>
<th>Solution</th>
<th>Benefits</th>
<th>Drawbacks</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wrappers</td>
<td>Consistent use, copy and move of memory can be managed, No explicit pointer manipulation for the customer</td>
<td>Additionnal code to implement and maintain</td>
</tr>
<tr>
<td>Smart pointers</td>
<td>Very little code to implement and maintain, consistent use of smart pointers, clean memory management</td>
<td>Difficult copy, requires the customer to manipulate pointers, <code>make_unique</code> instruction can not be used with private implementation structure</td>
</tr>
</tbody>
</table>
<h2 id="final-word">Final word</h2>
<p>For <code>RROSACE</code>, the simulation model library was written in <code>C89</code>, and the simulation framework in <code>C++11</code>.</p>
<p>My first strategy was to use the least amount of code to lighten maintenance, so I preferred smart pointers.
Before presenting my work and publishing the code, I revised my strategy and switched to wrapping, which has another implicit advantage, that of not having to explain the mechanics of smart pointers and RAII to the audience.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/blog/tags/c">c</a></li>
					
					<li><a href="/blog/tags/c&#43;&#43;">c&#43;&#43;</a></li>
					
					<li><a href="/blog/tags/c&#43;&#43;20">c&#43;&#43;20</a></li>
					
					<li><a href="/blog/tags/github">github</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
<hr><a class="soc" href="https://hnrck.io/" title="Web"><i data-feather="home"></i></a>|<a class="soc" href="https://github.com/hnrck/" title="GitHub"><i data-feather="github"></i></a>|<a class="soc" href="https://github.com/dhnrck/" title="Twitter"><i data-feather="twitter"></i></a>|<a class="soc" href="https://www.linkedin.com/in/henrick-deschamps" title="LinkedIn"><i data-feather="linkedin"></i></a>|<a class="soc" href="mailto://contact@hnrck.io" title="Mail"><i data-feather="mail"></i></a>|⚡️
	2020  © Henrick Deschamps |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script>
      feather.replace()
</script>

</div>
    </body>
</html>
